<p>Andy here: First, we started with setting up the ports for the sensors and motors - doing this properly is super important as it will make the rest of our code more manageable, and easier to work with. Doing this poorly could lead to many more issues later on, which we are trying to avoid.. We decided to use #define precompiler statements for all of the port setup so that we could easily change which port a motor or sensor is connected to without changing every other instance the motor/sensor is used. From that point on, we started to develop the robot, and test code alongside. With each motor and sensor that we put on, we had to check to make sure that port numbers were good, and that the sensor was returning appropriate values. Once the robot was finished building, we started testing driver control code, or opcontrol. We had three main parts of the robot that we needed to be able to simultaneously control: the driving, the flywheel and ball intake, and the descoring arm. To allow us to control all three at the same time, we put them in a task each, and multithreaded them. After consulting with our main driver, we made our drive a split arcade system, meaning one joystick controls the forward and backwards motion, and the other joystick controls the turning. Furthermore, we scaled the turning component (the second joystick) so that we can do precise turns while moving slowly, and still do fast turns while pushing the forwards/backwards joystick. This allows us to aim quicker and better (instead of overshooting) on the flags, but still be able to take advantage of the speed and agility of our 8 motor turbo drive base. Throughout testing, we had originally controlled the speed of the flywheel by setting a certain power for the motors, but we later realized that as voltage dropped throughout a match, the flywheel RPM for the same power would also drop, leading to inconsistent shots. We then mounted an encoder to detect the current RPM of the flywheel, and implemented a control loop for the flywheel, in its separate task. The three different control schemes that we had considered were take back half, PID, and Bang-Bang. There was one function that we wrote in util.c ( where we create our utility functions, to be used in both opcontrol and autonomous ), that would return the current flywheel RPM when called upon. This function operates by taking the ticks over time of the flywheel encoder, and then multiplies it by 3 - as we have the encoder geared at a 1:3 ratio from the encoder to the flywheel. We immediately ruled out Bang-Bang due to the stress that is places on the motors, and its inconsistency. Bang bang operates on the principle that if flywheel is at a target RPM, then the motors are set to a lower value (40-60), and if the flywheel RPM is not to speed, we would set motors to a higher value (127, for example). The reason this also had issues is because the same 127 is not constant, it depends on the battery voltage and just wasn’t consistent enough for us. Take back half operates on the principle that you, take the error, take half, and take it back. This was an improvement from Bang-Bang, but it still did not enough precision and speed. PID in the end, was chosen for its superior consistency and ability to precisely and quickly hit and stay at any desired target RPM. A PID control system works by having 3 different control loops all working together to achieve a fast ramp up, little oscillation, little overshoot, and little settling time. All three loops are based on the error between the current RPM and the target RPM. The P component, which stands for proportional, just takes the current error, scales it by kp (a custom constant which we tuned), and adds it to the current power of the motors. This lets the flywheel spin up at max speed when it is started to ramp up, but slow down when the RPM becomes close to the target and the error gets small. One thing to note here is that we add it to the power instead of setting the power to this value as a traditional PID controller would due to the flywheel needing a certain amount of idle power (different for all RPMs) to maintain each speed. Increasing the P value has the effect of decreasing the spin up time, but also increasing the overshoot. So, when we were tuning the PID controller, we gradually increased kp until the spin up was as fast as we wanted, while having not too much overshoot and oscillation. Next, we moved onto the D component which stands for derivative. The D component returns the derivative of the error over time, which is the difference between the current error and previous error, divided by the amount of time passed in between. This value was then multiplied by kd (another custom ID constant) and added to the power of the flywheel motors. Increasing kd has the effect of decreasing the overshoot, so we slowly increased it until the overshoot was sufficiently small. Finally, we implemented the I component, which stands for integral. The I component is the sum of all of the errors together, and serves to provide shrink the error even further after the error has decreased too much for the proportional portion to make a difference. To implement this, the sum of the errors is multiplied by ki (yet another PID constant) and added to the motor power and increased gradually, while also slightly tuning the other constants to achieve the flywheel behaviour that we wanted. To use this for driver control, we mapped the most general purpose RPM, which we found to be 3200, to the right shoulder button of the master joystick. This RPM was used for all flag shooting from the front of the field. Other RPMs that were useful, but more limited in use, such as for shooting from the back of the field, were put on the face buttons of the partner joystick. Furthermore, just in case the encoder for the PID controller breaks in the middle of a match, we added a manual override system on the partner joystick that changes the flywheel system to Bang-bang. We realized this was very important when our code failed once during a match because the encoder stopped returning values entirely. Having finished drive and flywheel control, we moved down onto the next movement functions, “auxiliaries”, if you will. This includes the intake, and the descoring arm. The intake is controlled by the left “shift” buttons, the top one we call the shoulder, and the bottom one we call the trigger. The trigger runs the intake in reverse, while the shoulder runs the intake in “feed” direction. This allows us to control the movement of the ball within the intake area, even allowing us to intake 2 balls at once even though the entire system is run by a single motor. Since the option to run the intake outwards was also available, the driver could intake a ball, run intake outwards so that the ball is at the bottom of the intake, and take in another ball. We ran one competition with the descore also on face buttons, but realized that that wasn’t going to work out the way that we wanted to, as it was impossible to fully drive the robot while also moving the descoring arm. With that in mind, we decided to move the descore to a joystick on a partner controller, which allowed for very fast descoring. Moving onto the autonomous code and sensors, we have the flywheel encoder, as mentioned before, encoders on each side of the drive base, an ultrasonic sensor at the front, and a gyro sensor on the bottom. But, due to having issues with various sensors (right drive OSE stopped returning values, ultrasonic was returning way too unreliable data even after being filtered, gyro damaged during transportation to our St Catharines competition) and not having replacement sensors available, we only used the flywheel encoder, and the left drive encoder. To make autonomous and skills coding easier and and clearer, we created various utility functions, namely driveStraight and pointTurn. DriveStraight takes in a number of encoder ticks, the power to run the motors at, and the direction of movement (forward or backward) and drives straight for the specified number of ticks. Similarly, pointTurn takes in a number of encoder ticks, the power to run the motors at, and the direction of movement (clockwise or counterclockwise) and turns for the specified number of ticks. We originally had error correction using the two driver encoders that would compensate if one side of the drive was running faster than the other, but we had to remove that part of the code when the right drive encoder broke. Also, since this part of the code was gone, we had to manually make sure that the left and right side were running at the same speed. We found that the right side of the drive base moved about 10% slower than the left side, so we manually scaled down the power given to the left side of the drive, as can be seen in the code below. After this, writing the autonomous code was just measuring encoder tick values and applying these functions. One other functionality we implemented was the option for choosing between multiple autons on the fly, using two potentiometers. One potentiometer is used to choose between the four starting positions available, and the other is used to choose between the autons available for that position. At the moment, we have 8 working autons, 2 for each starting position, and we hope to expand that to 24 separate autons as the season progresses. Here is one of our 8 autons.</p>
<p>title: 2381X Meeting Messages author: Anthony Luo date: 2018-12-10 16:00:00 -0500 This meeting mainly discussed the rebuild, or iteration three of our main robot. During this meeting we discussed limitations of the current robot, future intended capabilities, and also outlined a few metrics that our rebuild should be able to go by. The first and most important decision for us was still to decide the “playstyle” that we wanted to pursue. We, at this point, have gone to three competitions and we have a good idea of what the other robots in the region are (at least, early season). Knowing this, we can gauge where the robots are going to continue to go - which is incredibly important as it changes the physical aspects and dimensions of the robot. The difference between an offensive and defensive robot, and a robot designed to encounter defense, and one designed to outrun is very different. We have always ran a drive base faster than 200 rpm so that we can outrun v5 - we find this incredibly important as we are unable to provide more torque on our drive, and would thus burnout in a pushing match. With that decision having been made, it follows logically that our robot should retain a small form factor so that it is able to “slip” past opposing robots, as well as offering us more options on-field.<br />
Generally, the accepted dimensions of a robot (in terms of base width), range from 25 holes wide (12.5”), or 30 holes wide (15”). We have continually challenge this by having a robot be either 35 holes wide and 20 holes wide (17.5 and 10” respectively). Compared to a 30 hole robot, our robot is only 5” narrower, a difference that seems negligible at first, but really becomes apparent in matchplay with heavy defense. With this in mind, we also need to compare between the difference between the three different types of punchers. Eventually, we decided to choose the double catapult, this offers a few distinct advantages over either a flywheel or a puncher. Why is that? # Cycle time. A double catapult can hit two flags very very quickly, albeit from one location on field. The reason why this is so important - we anticipate heavy defense, and although flywheel and double puncher allow us to change the angle of our shot very quickly and very easily, we don’t know if we’ll ever be in a situation where we can accurately predict our motion and take two shots. With a double catapult, we’re able to drive into position for just a split second, and then we’re able to take a shot and score two flags, an 8 point swing. # Motor Distribution With a flywheel or angle changing puncher, it often requires multiple motors that can’t be linked to achieve the same task. That is, you need 2 motors on flywheel, 1 intake, 1 index for a flywheel system to score as fast and as efficiently as a catapult system, while an angle changing puncher requires 1 puncher, 1 angler, and 1 intake. 3 motors. None of them can be linked to other tasks very easily, and you’ll often require 2 motors on puncher. (those two motors can be linked, but you still have two other unlikable motors because they need 2 degrees of freedom). With a double catapult, all you need is 2 catapult, 1 inatke AND those two on the catapult can be linked together with a dmd style transmiission, allowing lift and catapult to be driver by the same two motors - something incredibly important for us. # Size + weight + complexity This is by far the simplest to build, the smallest, and the lightest. That’s an incredible benefit for us who want a light and fast robot. That’s all there is to it, punchers are complex, flywheels are very heavy and have a lot of rotational mass - catapults are simpler, legit a board that goes up and down, and you hit flags with it. The transmission does add complexity, but the complexity on a catapult transmission is very very simple. Our lift, and exact dimensions and spacing still need to be established, but we are in the process of CADing our robot, and designing our robot. Before we get straight into building, there’s a few things that Anthony has to say about building and CADing the robot first. We don’t like to CAD the entire robot out before we build - but we do like to CAD out general sections, add to it as our build progresses, etc etc because it allows us an incredible amount of flexibility in terms of visuallizing subsections, and knowing how much space we can allot to each. When I design robots, I tend to start wiht a general idea of the base, CAD the base, and THEN go to build the base. After that, I hold up lengths of C-channel on, around, over the base to get a sense of where stuff should go, how it should go, and where it might fit. Using motors in person also allows me to visualize how much space they’ll take up (which is a big issue when you go 20 wide, believe it or not). Using real life models also allows me to place items in a point at 3d space, and visualize around it. In cad, there is very little concept of space , and moving stuff around is quite difficult and quite odd. With that being said, I don’t think CAD for this robot is incredibly important. At this point in our season, we have established the general outlines, and are re-using CADs from previous robots (same base concepts, etcetc.). It has become faster for me to experiment and build in person rather to build in CAD, mostly because in person I have faster parts variablitiy. In the end, we may choose to finish a cad and include it, although the robot becomes complex enough where the CAD model slows down our computer to the point of being unusable, and is incredibly unhelpful for us. Tracking CAD progress is also difficult, screenshot management on windows is particularly terrible. A quick note about the notebook style over this build As we are building this robot over the break, we will have irregular meetings, and the developments made over these individual meetings lasting anywhere from 5 to 10 minutes may not be recorded. This is to make our lives easier, and allow us to develop a robot faster - notebooking takes a significant amount of time. With this in mind, we will be taking notes at the end of each development ‘period’ or cycle, this will become apparent as we develop our notebook. There are no dates for these meetings as they may span one day, or multiple days.</p>
